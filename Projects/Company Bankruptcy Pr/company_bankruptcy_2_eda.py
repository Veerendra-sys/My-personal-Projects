# -*- coding: utf-8 -*-
"""company bankruptcy 2 EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17gWpv6PtW9Mis9vS2OhPKaEM6TN7NVRC
"""

# Commented out IPython magic to ensure Python compatibility.
import sys
assert sys.version_info >= (3, 5)


import sklearn
assert sklearn.__version__ >= "0.20"

from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import SimpleImputer, KNNImputer, IterativeImputer
from sklearn.preprocessing import StandardScaler, RobustScaler, PolynomialFeatures
from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV
from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score
from sklearn.utils import class_weight
from sklearn.pipeline import Pipeline
from sklearn.linear_model import SGDClassifier
from sklearn.compose import ColumnTransformer
from sklearn.compose import make_column_selector
from imblearn.pipeline import make_pipeline

from scipy.stats import alpha, randint, uniform

from imblearn.over_sampling import RandomOverSampler, ADASYN, SMOTE
from tabulate import tabulate
import numpy as np
np.random.seed(42)
import pandas as pd
import tensorflow as tf
import keras
import os
# %matplotlib inline
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rc('axes', labelsize=14)
mpl.rc('xtick', labelsize=12)
mpl.rc('ytick', labelsize=12)

from google.colab import drive
import joblib

df=pd.read_csv("/content/data.csv")
df

df.isnull().sum()

df.isnull().sum().sum()

"""There are no missing values.

Now I am Checking the categorical column
"""

list1=[]
for i in df:
  x=df[i].value_counts()
  if len(x)<=2:
    list1.append(i)
  else:
    continue

#creating a for loop to get the categorical columns with 2 or less than 2 unique values
list1

"""Liability-Assets Flag:The Liability-Assets Flag is an indicator used in finance and accounting to classify whether a particular item falls under liabilities or assets on a company's balance sheet.

If the flag is set to "L" (Liability), it means the item represents an obligation or debt the company owes, such as loans, accounts payable, or accrued expenses.
If the flag is set to "A" (Asset), it means the item represents a resource or economic benefit owned by the company, such as cash, accounts receivable, inventory, or property.
"""

df[' Liability-Assets Flag'].unique()

df[' Liability-Assets Flag'].value_counts()
#This feature has a very large class imbalance and we can drop this feature.

"""Checking the Value Count of Output Variable

"""

df['Bankrupt?'].value_counts().sort_values().plot(kind = 'bar',color='green')

df['Bankrupt?'].value_counts()

220/(6599+220)
#The output variable is highly imbalanced with minority class accumulating just 3.2% of the data.

df.describe()

"""EDA

Since there are no missing values, we can jump into analyzing the data
"""

import seaborn as sns
sns.countplot(x='Bankrupt?', data=df, palette='Accent')

import seaborn as sns
sns.countplot(x='Bankrupt?', data=df, palette='Greens')

"""The dataset exhibits significant class imbalance, necessitating the application of Upsampling or Downsampling techniques to ensure a balanced distribution.

Upon inspecting the dataset using df.info(), we observe that most of the data is of type float64. The categorical features, represented as binary values (1 and 0), are stored as int64. To facilitate further analysis, we separate the numeric and categorical data accordingly.

There are only three categorical data columns, we will first explore these columns
"""

#Plotting count of liability-assets flag
print(df[' Liability-Assets Flag'].value_counts()) # Changed column name to ' Liability-Assets Flag'
sns.countplot(x=' Liability-Assets Flag',data=df,palette ='Greens') # Changed column name to ' Liability-Assets Flag'

"""The "Liability-Assets" flag serves as an indicator of an organization's financial standing. If total liabilities surpass assets, the flag is set to 1; otherwise, it remains 0. In most cases, companies tend to have assets that outweigh their liabilities, ensuring financial stability."""

#Finding bankrupt companies on the basis of liability-assets flag
print(df[[' Liability-Assets Flag','Bankrupt?']].value_counts()) # Changed 'LiabilityAssetsFlag' to ' Liability-Assets Flag'
sns.countplot(x = ' Liability-Assets Flag',hue = 'Bankrupt?',data = df,palette = 'Greens') # Changed 'LiabilityAssetsFlag' to ' Liability-Assets Flag'

"""A small percentage of organizations face bankruptcy despite having assets that exceed their liabilities. This can occur due to factors such as liquidity issues, poor cash flow management, or an inability to meet short-term obligations."""

#Plotting total count of net income flag
print(df[' Net Income Flag'].value_counts())  # Changed 'NetIncomeFlag' to ' Net Income Flag'
sns.countplot(x=' Net Income Flag', data=df, palette='Greens')  # Changed 'NetIncomeFlag' to ' Net Income Flag'

"""The "Net Income" flag indicates an organization's financial performance over the last two years. If the net income has been negative for both years, the flag is set to 1; otherwise, it remains 0. In our analysis, we found that all records reflect a consistent loss over the past two years."""

#Finding bankrupt companies on the basis of net income flag
print(df[[' Net Income Flag','Bankrupt?']].value_counts())  # Changed 'NetIncomeFlag' to ' Net Income Flag'
sns.countplot(x = ' Net Income Flag',hue = 'Bankrupt?',data = df,palette = 'Greens')  # Changed 'NetIncomeFlag' to ' Net Income Flag'

"""Many organizations that have suffered losses for the past two years have stabilized their business, thus avoiding bankruptcy.


"""

df2 = df.iloc[:,1:].copy()
X = df2
Y = df['Bankrupt?']

# Assuming df_1 is defined somewhere before and has the relevant columns.
# Assuming 'columns_after_vif' should contain a list of columns from df_1.

# Replace this with the actual logic to determine 'columns_after_vif'.
# For example, if it should contain all columns:
columns_after_vif = df.columns.tolist()

# Or if it should contain specific columns:
# columns_after_vif = ['column1', 'column2', 'column3']

def plotter():
  for var in columns_after_vif :
      plt.figure(figsize=(15,6))
      plt.subplot(1, 2, 1)
      fig = sns.boxplot(y=df[var])
      fig.set_title('')
      fig.set_ylabel(var)

      plt.subplot(1, 2, 2)
      fig = sns.distplot(df[var].dropna())
      fig.set_xlabel(var)

      plt.show()

plotter()

"""Conclusions:
1.The data has many outliers and it can be seen that it is very skewed.
2. Many columns are highly skewed, both in left and right direction.
3. We found that a lot of columns have high kurtosis.
4. A company is more likely to go bankrupt, if the value of features such as ROA(A) value is low.
5. Value of features such as Accounts Receivable Turnover is less likely to contribute to the bankruptcy of a company.
6. Only for higher values of features like Retained Earnings to Total Assets, a company is likely to stay non-bankrupt.
"""

#Plotting Those Columns After Capping the Outliers.
for col in columns_after_vif:
  upper_lim = df[col].quantile(.80)
  lower_lim = df[col].quantile(0.20)
  df.loc[(df[col] > upper_lim),col] = upper_lim
  df.loc[(df[col] < lower_lim),col] = lower_lim

plotter()

"""Several columns exhibit a leptokurtic distribution, meaning their kurtosis is higher than normal. This indicates that the data has heavier tails and a sharper peak compared to a normal distribution.

Correlation is a statistical measure that shows the relationship between two variables. It tells us how one variable changes in relation to another.
Types of Correlation
Positive Correlation ðŸ“ˆ

When one value increases, the other also increases.
Example: More study hours â†’ Higher exam scores.
Negative Correlation ðŸ“‰

When one value increases, the other decreases.
Example: More exercise â†’ Lower body weight.
No Correlation

When thereâ€™s no relationship between two variables.
Example: Shoe size & Intelligence (no connection).
"""

correlation = df.corr(method='pearson')
correlation_with_respect_to_target_variable = correlation.head(1)
correlation_with_respect_to_target_variable

plt.figure(figsize=(30,5))
sns.heatmap(correlation_with_respect_to_target_variable.iloc[:,0:20], annot=True,cmap="Greens")

plt.figure(figsize=(30,5))
sns.heatmap(correlation_with_respect_to_target_variable.iloc[:,20:40], annot=True,cmap="Greens")

plt.figure(figsize=(30,5))
sns.heatmap(correlation_with_respect_to_target_variable.iloc[:,40:60], annot=True,cmap="Greens")

plt.figure(figsize=(30,5))
sns.heatmap(correlation_with_respect_to_target_variable.iloc[:,60:80], annot=True,cmap="Greens")

plt.figure(figsize=(30,5))
sns.heatmap(correlation_with_respect_to_target_variable.iloc[:,80:100], annot=True,cmap="Greens")

"""After analyzing all the columns, we found that none of the features exhibited a strong correlation (greater than 0.5) with the target variable, bankruptcy.

The feature with the strongest negative correlation was 'Net Income to Total Assets', with a value of -0.32.
The feature with the strongest positive correlation was 'Debt Ratio', with a value of +0.25.

CONCLUSION:
The dataset lacks predictive power for linear algorithms, indicating that traditional linear models may not effectively capture patterns in the data. As a result, linear modeling techniques are not suitable for this dataset. Alternative approaches, such as non-linear models (e.g., Random Forest, Gradient Boosting, Neural Networks), should be considered for better predictive performance.
"""